// This code is based on the implementation of EC-JPAKE from mbed TLS

/*
 * Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.particle.ecjpake;

import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.spec.ECParameterSpec;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.util.BigIntegers;

import java.security.MessageDigest;
import java.security.SecureRandom;
import java.security.NoSuchAlgorithmException;
import java.math.BigInteger;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

/**
 * A class implementing the EC-JPAKE protocol as defined by the Thread specification.
 */
public class EcJpake {
    /**
     * Peer role.
     */
    public enum Role {
        /**
         * Client.
         */
        CLIENT,
        /**
         * Server.
         */
        SERVER
    }

    private class KeyPair {
        public BigInteger priv;
        public ECPoint pub;
    }

    private BigInteger xm1;
    private ECPoint Xm1;
    private BigInteger xm2;
    private ECPoint Xm2;
    private ECPoint Xp1;
    private ECPoint Xp2;
    private ECPoint Xp;
    private BigInteger s;

    private boolean hasPeerRound1;
    private boolean hasPeerRound2;
    private byte[] localRound1;
    private byte[] localRound2;
    private byte[] derivedSecret;

    private Role role;
    private byte[] localId;
    private byte[] peerId;
    private ECParameterSpec ec;
    private MessageDigest hash;
    private SecureRandom rand;

    private static final String CURVE_NAME = "P-256";
    private static final int CURVE_ID = 23; // RFC 4492, 5.1.1
    private static final String HASH_NAME = "SHA-256";
    private static final byte[] CLIENT_ID = "client".getBytes();
    private static final byte[] SERVER_ID = "server".getBytes();

    /**
     * Constructor.
     *
     * @param role The role of this peer.
     * @param secret The pre-shared secret.
     */
    public EcJpake(Role role, byte[] secret) {
        this(role, secret, new SecureRandom());
    }

    /**
     * Constructor.
     *
     * @param role The role of this peer.
     * @param secret The pre-shared secret.
     * @param random The secure random number generator to use.
     */
    public EcJpake(Role role, byte[] secret, SecureRandom random) {
        this.ec = ECNamedCurveTable.getParameterSpec(CURVE_NAME);
        if (this.ec == null) {
            throw new UnsupportedOperationException("Unsupported curve type");
        }
        try {
            this.hash = MessageDigest.getInstance(HASH_NAME);
        } catch (NoSuchAlgorithmException e) {
            throw new UnsupportedOperationException("Unsupported hash type", e);
        }
        this.rand = random;
        this.role = role;
        if (this.role == Role.CLIENT) {
            this.localId = CLIENT_ID;
            this.peerId = SERVER_ID;
        } else {
            this.localId = SERVER_ID;
            this.peerId = CLIENT_ID;
        }
        this.s = new BigInteger(1, secret);
        this.xm1 = null;
        this.Xm1 = null;
        this.xm2 = null;
        this.Xm2 = null;
        this.Xp1 = null;
        this.Xp2 = null;
        this.Xp = null;
        this.hasPeerRound1 = false;
        this.hasPeerRound2 = false;
        this.localRound1 = null;
        this.localRound2 = null;
        this.derivedSecret = null;
    }

    /**
     * Read a message generated by the peer for the first round of the protocol.
     *
     * @param in The input stream.
     */
    public void readRound1(InputStream in) throws IOException {
        if (this.hasPeerRound1) {
            throw new IllegalStateException("Invalid protocol state");
        }
        this.Xp1 = this.readPoint(in);
        this.readZkp(in, this.ec.getG(), this.Xp1, this.peerId);
        this.Xp2 = this.readPoint(in);
        this.readZkp(in, this.ec.getG(), this.Xp2, this.peerId);
        this.hasPeerRound1 = true;
    }

    /**
     * Generate and write a message for the first round of the protocol.
     *
     * @param out The output stream.
     */
    public void writeRound1(OutputStream out) throws IOException {
        if (this.localRound1 == null) {
            ByteArrayOutputStream out2 = new ByteArrayOutputStream();
            KeyPair kp = this.genKeyPair(this.ec.getG());
            this.xm1 = kp.priv;
            this.Xm1 = kp.pub;
            this.writePoint(out2, this.Xm1);
            this.writeZkp(out2, this.ec.getG(), this.xm1, this.Xm1, this.localId);
            kp = this.genKeyPair(this.ec.getG());
            this.xm2 = kp.priv;
            this.Xm2 = kp.pub;
            this.writePoint(out2, this.Xm2);
            this.writeZkp(out2, this.ec.getG(), this.xm2, this.Xm2, this.localId);
            this.localRound1 = out2.toByteArray();
        }
        out.write(this.localRound1);
    }

    /**
     * Read a message generated by the peer for the second round of the protocol.
     *
     * @param in The input stream.
     */
    public void readRound2(InputStream in) throws IOException {
        if (!this.hasPeerRound1 || this.localRound1 == null || this.hasPeerRound2) {
            throw new IllegalStateException("Invalid protocol state");
        }
        if (this.role == Role.CLIENT) {
            this.readCurveId(in);
        }
        ECPoint G = this.Xm1.add(this.Xm2).add(this.Xp1);
        this.Xp = this.readPoint(in);
        this.readZkp(in, G, this.Xp, this.peerId);
        this.hasPeerRound2 = true;
    }

    /**
     * Generate and write a message for the second round of the protocol.
     *
     * @param out The output stream.
     */
    public void writeRound2(OutputStream out) throws IOException {
        if (this.localRound2 == null) {
            if (!this.hasPeerRound1 || this.localRound1 == null) {
                throw new IllegalStateException("Invalid protocol state");
            }
            ByteArrayOutputStream out2 = new ByteArrayOutputStream();
            ECPoint G = this.Xp1.add(this.Xp2).add(this.Xm1);
            BigInteger xm = this.mulSecret(this.xm2, this.s, false /* negate */);
            ECPoint Xm = G.multiply(xm);
            if (this.role == Role.SERVER) {
                this.writeCurveId(out2);
            }
            this.writePoint(out2, Xm);
            this.writeZkp(out2, G, xm, Xm, this.localId);
            this.localRound2 = out2.toByteArray();
        }
        out.write(this.localRound2);
    }

    /**
     * Derive a shared secret.
     *
     * @return The shared secret.
     */
    public byte[] deriveSecret() {
        if (this.derivedSecret == null) {
            if (!this.hasPeerRound2) {
                throw new IllegalStateException("Invalid protocol state");
            }
            BigInteger xm2s = this.mulSecret(this.xm2, this.s, true /* negate */);
            ECPoint K = this.Xp.add(this.Xp2.multiply(xm2s)).multiply(this.xm2);
            this.derivedSecret = this.hash.digest(BigIntegers.asUnsignedByteArray(K.normalize().getXCoord().toBigInteger()));
        }
        return this.derivedSecret;
    }

    private void readZkp(InputStream in, ECPoint G, ECPoint X, byte[] id) throws IOException {
        ECPoint V = this.readPoint(in);
        BigInteger r = this.readNum(in);
        BigInteger h = this.zkpHash(G, V, X, id);
        ECPoint VV = G.multiply(r).add(X.multiply(h.mod(this.ec.getN())));
        if (!VV.equals(V)) {
            throw new RuntimeException("Validation failed");
        }
    }

    private void writeZkp(OutputStream out, ECPoint G, BigInteger x, ECPoint X, byte[] id) throws IOException {
        KeyPair kp = this.genKeyPair(G);
        BigInteger v = kp.priv;
        ECPoint V = kp.pub;
        BigInteger h = this.zkpHash(G, V, X, id);
        BigInteger r = v.subtract(x.multiply(h)).mod(this.ec.getN());
        this.writePoint(out, V);
        this.writeNum(out, r);
    }

    private BigInteger zkpHash(ECPoint G, ECPoint V, ECPoint X, byte[] id) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        this.writeZkpHashPoint(out, G);
        this.writeZkpHashPoint(out, V);
        this.writeZkpHashPoint(out, X);
        this.writeUint32(out, id.length);
        out.write(id);
        byte[] hash = this.hash.digest(out.toByteArray());
        BigInteger h = new BigInteger(1, hash);
        return h.mod(this.ec.getN());
    }

    private void writeZkpHashPoint(OutputStream out, ECPoint point) throws IOException {
        byte[] encoded = point.getEncoded(false /* compressed */);
        this.writeUint32(out, encoded.length);
        out.write(encoded);
    }

    private BigInteger mulSecret(BigInteger X, BigInteger S, boolean negate) {
        BigInteger b = new BigInteger(1, this.randBytes(16));
        b = b.multiply(this.ec.getN()).add(S);
        BigInteger R = X.multiply(b);
        if (negate) {
            R = R.negate();
        }
        return R.mod(this.ec.getN());
    }

    private ECPoint readPoint(InputStream in) throws IOException {
        int len = this.readByte(in);
        byte[] encoded = this.read(in, len);
        return this.ec.getCurve().decodePoint(encoded);
    }

    private void writePoint(OutputStream out, ECPoint point) throws IOException {
        byte[] encoded = point.getEncoded(false /* compressed */);
        if (encoded.length > 255) {
            throw new RuntimeException("Encoded ECPoint is too long");
        }
        out.write(encoded.length);
        out.write(encoded);
    }

    private BigInteger readNum(InputStream in) throws IOException {
        int len = this.readByte(in);
        byte[] encoded = this.read(in, len);
        return new BigInteger(1, encoded);
    }

    private void writeNum(OutputStream out, BigInteger val) throws IOException {
        byte[] encoded = BigIntegers.asUnsignedByteArray(val);
        if (encoded.length > 255) {
            throw new RuntimeException("Encoded BigInteger is too long");
        }
        out.write(encoded.length);
        out.write(encoded);
    }

    private void readCurveId(InputStream in) throws IOException {
        int type = this.readByte(in);
        if (type != 3) { // ECCurveType.named_curve
            throw new RuntimeException("Invalid message");
        }
        int id = this.readUint16(in);
        if (id != CURVE_ID) {
            throw new RuntimeException("Unexpected curve type");
        }
    }

    private void writeCurveId(OutputStream out) throws IOException {
        out.write(3); // ECCurveType.named_curve
        this.writeUint16(out, CURVE_ID);
    }

    private int readUint16(InputStream in) throws IOException {
        byte[] b = this.read(in, 2);
        return ((int)b[0] << 8) | (int)b[1];
    }

    private void writeUint16(OutputStream out, int val) throws IOException {
        byte[] b = new byte[2];
        b[0] = (byte)((val >>> 8) & 0xff);
        b[1] = (byte)(val & 0xff);
        out.write(b);
    }

    private void writeUint32(OutputStream out, int val) throws IOException {
        byte[] b = new byte[4];
        b[0] = (byte)((val >>> 24) & 0xff);
        b[1] = (byte)((val >>> 16) & 0xff);
        b[2] = (byte)((val >>> 8) & 0xff);
        b[3] = (byte)(val & 0xff);
        out.write(b);
    }

    private int readByte(InputStream in) throws IOException {
        int b = in.read();
        if (b < 0) {
            throw new RuntimeException("Unexpected end of stream");
        }
        return b;
    }

    private byte[] read(InputStream in, int bytes) throws IOException {
        byte[] b = new byte[bytes];
        int offs = 0;
        while (offs < bytes) {
            int r = in.read(b, offs, bytes - offs);
            if (r < 0) {
                throw new RuntimeException("Unexpected end of stream");
            }
            offs += r;
        }
        return b;
    }

    private KeyPair genKeyPair(ECPoint G) {
        KeyPair kp = new KeyPair();
        kp.priv = BigIntegers.createRandomInRange(BigInteger.ONE, this.ec.getN().subtract(BigInteger.ONE), this.rand);
        kp.pub = G.multiply(kp.priv);
        return kp;
    }

    private byte[] randBytes(int bytes) {
        byte[] b = new byte[bytes];
        this.rand.nextBytes(b);
        return b;
    }
}
